import "@stdlib/deploy";
import "@stdlib/ownable";

message RegisterBot {
    manifestUrl: String;
}

message SetWalletManifest {
    // nonce: Int as uint64;
    manifestUrl: String;
}

message WalletInfo {
    manifestUrl: String;
    owner: Address;
    master: Address;
}

message WalletManifestChangedEvent {
    oldManifestUrl: String;
    newManifestUrl: String;
}

message WalletCreatedEvent {
    wallet: Address;
    owner: Address;
}

message WalletWithdraw {
}

// SubmitAttestTask is the message that generated by the submiter/bot,
// and will be sent to the master contract,
// master contract will forward the message to the wallet contract withing taskId/status/walletAddress.
message SubmitAttestTask {
    // task id will be generated by the master contract
    taskId: Int? as uint64;
    // status of the task, can be "pending", "verified" or "rejected", will be set by the master contract
    status: String? = "pending";
    // walletAddress is the address of the wallet contract, will be set by the master contract
    walletAddress: Address?;
    // proofUrl is the url of the proof, better be stored at arweave
    proofUrl: String;
    // attestValue is the value that will be paid to the attester,
    // the value in the message should be greater than attestValue.
    attestValue: Int;
}

// AttestTaskResult is the result of the attest task, generated by the verifier oracle,
// and will be sent to the wallet contract.
message AttestTaskResult {
    // taskId is the id of the attest task
    taskId: Int as uint64;
    // status is the result of the attest task, can be "verified" or "rejected"
    status: String;
    // verifiedUrl is the url of the verified proof, better be stored at arweave
    verifiedUrl: String;
    // verifier is the address of the verifier oracle,
    // this value will be set by the wallet contract.
    verifier: Address?;
}

// this is the master contract of TON.
contract Attest with Deployable, Ownable {
    owner: Address;
    attestTaskId: Int as uint64 = 0;

    init(){
        self.owner = sender();
    }

    // create Bot for the sender
    receive(msg: RegisterBot){
        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: false,
                mode: SendRemainingValue,
                body: SetWalletManifest{
                    // nonce: nonce,
                    manifestUrl: msg.manifestUrl
                }.toCell(),
                code: walletInit.code,
                data: walletInit.data
            }
        );
    }

    fun getWalletInit(walletOwner: Address): StateInit {
        return initOf Bot(myAddress(), walletOwner);
    }

    // update manifest of Bot
    receive(msg: SetWalletManifest){
        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: false,
                mode: SendRemainingValue,
                body: SetWalletManifest{
                    // nonce: nonce,
                    manifestUrl: msg.manifestUrl
                }.toCell()
            }
        );
        // self.setManifestNonce.set(walletAddr, nonce + 1);
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();

        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue >= ton("0.05"), "Attest value should be greater than 0.05");

        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        msg.taskId = self.attestTaskId;
        msg.status = "pending";
        msg.walletAddress = walletAddr;

        // send the task to Bot
        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: false,
                mode: SendRemainingValue,
                body: msg.toCell()
            }
        );

        self.attestTaskId = self.attestTaskId + 1;
    }
}

// Bot is the wallet contract, will be deployed by the master contract
// to every submiter/bot. wallet contract will take the responsibility of
// storing the manifest and the attest task.
contract Bot with Ownable {
    owner: Address;
    master: Address;
    manifestUrl: String = "";
    // attestTaskIncentives is the balance of the attest task,
    // the key is the task id, the value is the incentive of the task.
    attestTaskIncentives: map<Int as uint64, Int> = emptyMap();
    // lockedValue is the value that is locked in the contract, cannot be withdrawed.
    lockedValue: Int = ton("0.1");

    init(master: Address, owner: Address){
        self.master = master;
        self.owner = owner;
    }

    // master can set manifest of Bot
    receive(msg: SetWalletManifest){
        require(self.master == sender(), "Only master can set manifest");

        emit(WalletManifestChangedEvent{
            oldManifestUrl: self.manifestUrl,
            newManifestUrl: msg.manifestUrl
        }.toCell());

        self.manifestUrl = msg.manifestUrl;
    }

    // owner can withdraw all balance
    receive(msg: WalletWithdraw){
        require(self.owner == sender(), "Only master can withdraw");
        require(myBalance() > self.lockedValue, "Balance not enough");
        send(SendParameters{
                to: sender(),
                value: (myBalance() - context().value) - self.lockedValue,
                bounce: false,
                mode: SendRemainingValue
            }
        );
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();
        require(self.manifestUrl != "", "Manifest not set");
        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue >= ton("0.05"), "Attest value should be greater than 0.05");

        emit(msg.toCell());
        self.lockedValue = self.lockedValue + msg.attestValue;
    }

    // attest task result, and send the incentive to the verifier
    receive(msg: AttestTaskResult) {
        let incentive = self.attestTaskIncentives.get(msg.taskId);
        require(incentive != null, "Task not found");

        msg.verifier = sender();
        emit(msg.toCell());

        // TODO: need to check the correctness of the result.
        //
        // do not send the incentive to the verifier immediately,
        // add some time lock mechanism, like OP,
        // release the incentive after some period of time to give the submiter a chance to challenge.
        send(SendParameters{
                to: sender(),
                value: incentive!!,
                bounce: false,
                mode: SendRemainingValue
            }
        );
        self.attestTaskIncentives.set(msg.taskId, null);
    }

    get fun master(): String {
        return self.master.toString();
    }

    get fun manifestUrl(): String {
        return self.manifestUrl;
    }

    get fun taskIncentives(taskId: Int): Int {
        let val = self.attestTaskIncentives.get(taskId);
        if (val == null) {
            return 0;
        }

        return val!!;
    }

    get fun lockedValue(): Int {
        return self.lockedValue;
    }
}
