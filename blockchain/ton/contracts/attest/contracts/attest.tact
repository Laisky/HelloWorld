import "@stdlib/deploy";
import "@stdlib/ownable";
import "@stdlib/stoppable";


const MinimalOraclePledgeValue: Int = ton("1");


message RegisterBot {
    manifestUrl: String;
    // botOwner is the address of the bot owner
    botOwner: Address;
}

message RegisterOracle {
    // pledgeValue is the value that the oracle will pledge,
    // the minimum pledge value is 1 TON.
    pledgeValue: Int;
    // oracleOwner is the address of the oracle owner
    oracleOwner: Address;
}

message SetBotManifest {
    nonce: Int as uint64;
    manifestUrl: String;
}

message WalletInfo {
    manifestUrl: String;
    owner: Address;
    master: Address;
}

message WalletManifestChangedEvent {
    oldManifestUrl: String;
    newManifestUrl: String;
}

message WalletCreatedEvent {
    wallet: Address;
    owner: Address;
}


// SubmitAttestTask is the message that generated by the submiter/bot,
// and will be sent to the master contract,
// master contract will forward the message to the wallet contract withing taskId/status/botAddress.
message SubmitAttestTask {
    // proofUrl is the url of the proof, better be stored at arweave
    proofUrl: String;
    // attestValue is the value that will be paid to the attester,
    // the value in the message should be greater than attestValue.
    attestValue: Int;
}

message PublishAttestTask {
    // task id will be generated by the bot contract.
    // every task id is unique in the scope of the bot contract.
    taskId: Int as uint64;
    // status of the task, can be "pending", "verified" or "rejected", will be set by the master contract
    status: String = "pending";
    // botOwner is the address of the bot owner
    botOwner: Address;
    // proofUrl is the url of the proof, better be stored at arweave
    proofUrl: String;
    // attestValue is the value that will be paid to the attester,
    // the value in the message should be greater than attestValue.
    attestValue: Int;
}

// AttestTaskResult is the result of the attest task, generated by the verifier oracle,
// and will be sent to the wallet contract.
message AttestTaskResult {
    // taskId is the id of the attest task
    taskId: Int as uint64;
    // status is the result of the attest task, can be "verified" or "rejected"
    status: String;
    // verifiedUrl is the url of the verified proof, better be stored at arweave
    verifiedUrl: String;
    // botOwner is the address of the bot owner,
    botOwner: Address;
    // oracleOwner is the address of the owner of the oracle contract
    oracleOwner: Address;
}

message GainAttestIncentive {
    taskId: Int as uint64;
    incentive: Int;
    // releaseTime when to release the incentive
    releaseTime: Int as uint32;
    botOwner: Address;
}

message SetStaticTaxFee {
    staticTaxFee: Int;
}

trait Txable with Ownable {
    owner: Address;
    staticTaxFee: Int = ton("0");

    get fun staticTaxFee(): Int {
        return self.staticTaxFee;
    }

    receive(msg: SetStaticTaxFee){
        self.requireOwner();

        self.staticTaxFee = msg.staticTaxFee;
        let answer = beginString()
            .concat("set static tax fee to ")
            .concat(msg.staticTaxFee.toString())
            .toString();
        self.reply(answer.asComment());
    }
}

// SetEmitFee is the message that will be sent to the master contract,
// to set the fee when emitting log.
message SetEmitFee {
    emitFee: Int;
}


// Common is the common trait that will be used by the master contract
trait Common with Ownable {
    owner: Address;
    emitFee: Int = ton("0.01");
    nonce: Int = 0;

    get fun emitFee(): Int {
        return self.emitFee;
    }

    receive(msg: SetEmitFee){
        self.requireOwner();

        self.emitFee = msg.emitFee;

        let answer = beginString()
            .concat("set emit fee to ")
            .concat(msg.emitFee.toString())
            .toString();
        self.reply(answer.asComment());
    }

    get fun nonce(): Int {
        return self.nonce;
    }
}

// this is the master contract of TON.
contract Attest with Deployable, OwnableTransferable, Txable, Common {
    owner: Address;
    nonce: Int as uint64 = 0;
    minimalAttestFee: Int = ton("0.05");
    forwardFee : Int = ton("0.03");
    emitFee: Int = ton("0.01");
    staticTaxFee: Int = ton("0.01");

    init(){
        self.owner = sender();
    }

    fun getBot(owner: Address): StateInit {
        return initOf Bot(myAddress(), owner);
    }

    fun getOracle(owner: Address): StateInit {
        return initOf Oracle(myAddress(), owner);
    }

    // create bot contract for the sender,
    // all remaining value will be sent to the bot contract.
    receive(msg: RegisterBot){
        let ctx = context();
        nativeReserve(myBalance() - ctx.value + self.emitFee + self.staticTaxFee, ReserveExact);

        msg.botOwner = sender();
        emit(msg.toCell());

        let bot = self.getBot(sender());
        let botAddr = contractAddress(bot);

        // deploy bot contract and send the manifest to the bot
        send(SendParameters{
                to: botAddr,
                value: 0,
                mode: SendRemainingBalance,
                bounce: false,
                body: SetBotManifest{
                    nonce: 0,
                    manifestUrl: msg.manifestUrl
                }.toCell(),
                code: bot.code,
                data: bot.data
            }
        );
    }

    // create oracle contract for the sender,
    // all remaining value will be sent to the oracle contract.
    receive(msg: RegisterOracle){
        let ctx = context();
        nativeReserve(myBalance() - ctx.value + self.emitFee + self.staticTaxFee, ReserveExact);

        msg.oracleOwner = sender();
        emit(msg.toCell());

        let oracle = self.getOracle(sender());
        let oracleAddr = contractAddress(oracle);

        // deploy oracle contract
        send(SendParameters{
                to: oracleAddr,
                value: 0,
                mode: SendRemainingBalance,
                bounce: false,
                code: oracle.code,
                data: oracle.data
            }
        );
    }

    // publish attest task
    receive(msg: PublishAttestTask){
        let ctx = context();
        nativeReserve(myBalance() - ctx.value + self.emitFee + self.staticTaxFee, ReserveExact);

        // verify sender is the owner of the bot
        let bot = self.getBot(msg.botOwner);
        let botAddr = contractAddress(bot);
        require(botAddr == sender(), "Only bot contract can publish attest task");

        require(ctx.value >= self.emitFee + self.staticTaxFee, "Value not enough");

        // emit attest task to offchain oracle workers
        //
        // Assuming this will use 0.01.
        // In actual, it will cost around 0.007 on the test network.
        emit(msg.toCell());

        // refund the rest value to the bot
        send(SendParameters{
                to: botAddr,
                value: 0,
                mode: SendRemainingBalance,
                bounce: false,
                body: "PublishAttestTask".asComment()
            }
        );
    }
}

// Bot is the wallet contract, will be deployed by the master contract
// to every submiter/bot. wallet contract will take the responsibility of
// storing the manifest and the attest task.
contract Bot with Deployable ,Ownable, Common {
    owner: Address;
    nonce: Int as uint64 = 0;
    master: Address;
    manifestUrl: String = "";
    // attestTaskIncentives is the balance of the attest task,
    // the key is the task id, the value is the incentive of the task.
    attestTaskIncentives: map<Int as uint64, Int> = emptyMap();
    // lockedValue is the value that is locked in the contract, cannot be withdrawed.
    // To ensure there is enough rent, a deposit of at least 1 TON is necessary.
    lockedValue: Int = ton("0.01");
    emitFee: Int = ton("0.01");
    attestTaskId: Int as uint64 = 0;

    init(master: Address, owner: Address){
        let ctx = context();
        require(myBalance() >= self.lockedValue, "Value not enough");

        self.master = master;
        self.owner = owner;
    }

    // master can set manifest of Bot
    receive(msg: SetBotManifest){
        require(sender() == self.master || sender() == self.owner, "Only master contract or owner can set manifest");
        require(myBalance() >= self.lockedValue, "Value not enough");

        require(msg.nonce == self.nonce, "Nonce not match");
        self.nonce = self.nonce + 1;

        emit(WalletManifestChangedEvent{
            oldManifestUrl: self.manifestUrl,
            newManifestUrl: msg.manifestUrl
        }.toCell());

        self.manifestUrl = msg.manifestUrl;
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();
        nativeReserve(myBalance() - ctx.value + msg.attestValue, ReserveExact);

        self.requireOwner();
        require(self.manifestUrl != "", "Manifest not set");
        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue >= ton("0.05"), "Attest value should be greater than 0.05");
        // Since of contract has to pay the rent for the storage,
        // if the contract balance is not enough for incentive,
        // the contract will not be allowed to receive new attest task.
        require(myBalance() - self.lockedValue - msg.attestValue >= 0, "Balance is less than the locked value");

        // lock the incentive of the task for the attester
        self.lockedValue = self.lockedValue + msg.attestValue;

        // save the incentive of the task
        self.attestTaskIncentives.set(self.attestTaskId, msg.attestValue);

        // forward the task to the master contract
        let pubMsg = PublishAttestTask{
            taskId: self.attestTaskId,
            status: "pending",
            botOwner: self.owner,
            proofUrl: msg.proofUrl,
            attestValue: msg.attestValue
        };
        send(SendParameters{
                to: self.master,
                value: 0,
                mode: SendRemainingBalance,
                bounce: false,
                body: pubMsg.toCell()
            }
        );
    }

    // attest task result, and send the incentive to the verifier
    receive(msg: AttestTaskResult) {
        let incentive = self.attestTaskIncentives.get(msg.taskId);
        require(incentive != null, "Task not found");

        let ctx = context();
        // myBalance() - ctx.value - incentive!! must be non-negative
        nativeReserve(myBalance() - ctx.value - incentive!! + self.emitFee, ReserveExact);

        // sender must be oracle contract
        let oracle = initOf Oracle(self.master, msg.oracleOwner);
        let oracleAddr = contractAddress(oracle);
        require(oracleAddr == sender(), "Only oracle contract can submit attest task result");

        emit(msg.toCell());

        // send the incentive to the verifier
        send(SendParameters{
                to: sender(),
                value: 0,
                mode: SendRemainingBalance,
                bounce: false,
            }
        );

        self.attestTaskIncentives.set(msg.taskId, null);
        self.lockedValue = self.lockedValue - incentive!!;
    }

    // owner can withdraw all balance
    receive("withdraw"){
        self.requireOwner();

        nativeReserve(self.lockedValue, ReserveExact);

        send(SendParameters{
                to: sender(),
                value: ton("0"),
                bounce: false,
                mode: SendRemainingBalance
            }
        );
    }

    get fun master(): String {
        return self.master.toString();
    }

    get fun manifestUrl(): String {
        return self.manifestUrl;
    }

    get fun taskIncentives(taskId: Int): Int {
        let val = self.attestTaskIncentives.get(taskId);
        if (val == null) {
            return 0;
        }

        return val!!;
    }

    get fun lockedValue(): Int {
        return self.lockedValue;
    }
}

contract Oracle with Deployable, Ownable, Common {
    owner: Address;
    nonce: Int as uint64 = 0;
    master: Address;
    // lockedValue is the pledge value that is locked in the contract,
    // cannot be withdrawed.
    lockedValue: Int = ton("0.01");
    emitFee: Int = ton("0.01");

    // lockedIncentives stores the unreleased incentives of the attest task,
    // the key is the index, the value is the incentive.
    lockedIncentives: map<Int as uint64, GainAttestIncentive> = emptyMap();
    lockedIncentiveMaxIdx: Int as uint64 = 0;

    init(master: Address, owner: Address){
        let ctx = context();

        require(ctx.value >= self.lockedValue + MinimalOraclePledgeValue, "Value not enough");

        self.master = master;
        self.owner = owner;
        self.lockedValue = self.lockedValue + MinimalOraclePledgeValue;
    }

    // owner can withdraw all balance
    receive("withdraw"){
        self.requireOwner();

        nativeReserve(self.lockedValue, ReserveExact);

        send(SendParameters{
                to: sender(),
                value: ton("0"),
                bounce: false,
                mode: SendRemainingBalance
            }
        );
    }

    // submit attest task result
    receive(msg: AttestTaskResult){
        let ctx = context();
        nativeReserve(self.lockedValue, ReserveExact);

        self.requireOwner();
        require(myBalance() > self.lockedValue, "Balance is less than the locked value");

        // get bot address
        let bot = initOf Bot(self.master, msg.botOwner);
        let botAddr = contractAddress(bot);

        // forward the result to the bot
        send(SendParameters{
                to: botAddr,
                value: ton("0"),
                bounce: false,
                body: msg.toCell(),
                mode: SendRemainingValue
            }
        );
    }

    receive(msg: GainAttestIncentive){
        let ctx = context();
        nativeReserve(self.lockedValue, ReserveExact);

        // sender must be the bot contract
        let bot = initOf Bot(self.master, msg.botOwner);
        let botAddr = contractAddress(bot);
        require(botAddr == sender(), "Only bot contract can pay incentive");

        require(ctx.value >= msg.incentive, "Value not enough");

        if (now() < msg.releaseTime) {
            // lock the incentive
            let i = 0;
            while (i >= 0) {
                // find the first empty slot to store the incentive
                if (self.lockedIncentives.get(i) == null) {
                    self.lockedValue = self.lockedValue + msg.incentive;
                    self.lockedIncentives.set(i, msg);
                    if (i > self.lockedIncentiveMaxIdx) {
                        self.lockedIncentiveMaxIdx = i;
                    }

                    i = -1;
                }

                i = i + 1;
            }
        }

        // refund the rest value to the bot
        send(SendParameters{
                to: sender(),
                value: ctx.value - msg.incentive,
                bounce: false,
            }
        );
    }

    receive("gather_incentive"){
        let ctx = context();
        nativeReserve(self.lockedValue, ReserveExact);

        let nowTime = now();

        let i: Int = 0;
        while (i <= self.lockedIncentiveMaxIdx) {
            let incentive = self.lockedIncentives.get(i);
            if (incentive != null && nowTime >= incentive!!.releaseTime) {
                // release the incentive
                self.lockedIncentives.set(i, null);
                self.lockedValue = self.lockedValue - incentive!!.incentive;
            }

            i = i + 1;
        }

        // refund the rest value to the bot
        send(SendParameters{
                to: sender(),
                value: ctx.value,
                bounce: false,
            }
        );
    }

    get fun lockedValue(): Int {
        return self.lockedValue;
    }

    get fun lockedIncentiveMaxIdx(): Int {
        let total = 0;
        let i: Int = 0;
        while (i <= self.lockedIncentiveMaxIdx) {
            let incentive = self.lockedIncentives.get(i);
            if (incentive != null) {
                total = total + incentive!!.incentive;
            }

            i = i + 1;
        }

        return total;
    }
}
