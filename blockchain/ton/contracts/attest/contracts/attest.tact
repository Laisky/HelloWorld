import "@stdlib/deploy";
import "@stdlib/ownable";

message RegisterBot {
    manifestUrl: String;
}

message SetWalletManifest {
    // nonce: Int as uint64;
    manifestUrl: String;
}

message WalletInfo {
    manifestUrl: String;
    owner: Address;
    master: Address;
}

message WalletManifestChangedEvent {
    oldManifestUrl: String;
    newManifestUrl: String;
}

message WalletCreatedEvent {
    wallet: Address;
    owner: Address;
}

message WalletWithdraw {
}

// SubmitAttestTask is the message that generated by the submiter/bot,
// and will be sent to the master contract,
// master contract will forward the message to the wallet contract withing taskId/status/walletAddress.
message SubmitAttestTask {
    // task id will be generated by the master contract
    taskId: Int? as uint64;
    // status of the task, can be "pending", "verified" or "rejected", will be set by the master contract
    status: String? = "pending";
    // walletAddress is the address of the wallet contract, will be set by the master contract
    walletAddress: Address?;
    // proofUrl is the url of the proof, better be stored at arweave
    proofUrl: String;
    // attestValue is the value that will be paid to the attester,
    // the value in the message should be greater than attestValue.
    attestValue: Int as uint32;
}

// AttestTaskResult is the result of the attest task, generated by the verifier oracle,
// and will be sent to the wallet contract.
message AttestTaskResult {
    // taskId is the id of the attest task
    taskId: Int as uint64;
    // status is the result of the attest task, can be "verified" or "rejected"
    status: String;
    // verifiedUrl is the url of the verified proof, better be stored at arweave
    verifiedUrl: String;
    // verifier is the address of the verifier oracle,
    // this value will be set by the wallet contract.
    verifier: Address?;
}

// this is the master contract of TON.
contract Attest with Deployable, Ownable {
    owner: Address;
    // setManifestNounce: map<Address, Int as uint32> = emptyMap();
    attestTaskId: Int as uint64 = 0;

    init(){
        self.owner = sender();
    }

    // create AttestWallet for the sender
    receive(msg: RegisterBot){
        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);
        // let nonce = self.getManifestNonce(walletAddr);

        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: true,
                mode: SendRemainingValue,
                body: SetWalletManifest{
                    // nonce: nonce,
                    manifestUrl: msg.manifestUrl
                }.toCell(),
                code: walletInit.code,
                data: walletInit.data
            }
        );
        // self.setManifestNonce.set(walletAddr, nonce + 1);
    }

    fun getWalletInit(walletOwner: Address): StateInit {
        return initOf AttestWallet(myAddress(), walletOwner);
    }

    // fun getManifestNonce(walletOwner: Address): Int {
    //     let nonce: Int = 0;
    //     if (self.setManifestNonce.get(sender()) != null) {
    //         nonce = self.setManifestNonce.get(sender())!!;
    //     }
    //     return nonce;
    // }

    // update manifest of AttestWallet
    receive(msg: SetWalletManifest){
        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: true,
                mode: SendRemainingValue,
                body: SetWalletManifest{
                    // nonce: nonce,
                    manifestUrl: msg.manifestUrl
                }.toCell()
            }
        );
        // self.setManifestNonce.set(walletAddr, nonce + 1);
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();
        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue > ton("0.05"), "Attest value should be greater than 0.05");

        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        msg.taskId = self.attestTaskId;
        msg.status = "pending";
        msg.walletAddress = walletAddr;

        // notify to the submiter
        self.notify(msg.toCell());

        // send the task to AttestWallet
        send(SendParameters{
                to: walletAddr,
                value: 0,
                bounce: true,
                mode: SendRemainingValue,
                body: msg.toCell()
            }
        );

        self.attestTaskId = self.attestTaskId + 1;
    }
}

// AttestWallet is the wallet contract, will be deployed by the master contract
// to every submiter/bot. wallet contract will take the responsibility of
// storing the manifest and the attest task.
contract AttestWallet with Ownable {
    owner: Address;
    master: Address;
    manifestUrl: String = "";
    // manifestNonce: Int as uint64 = 0;
    // attestTaskIncentives is the balance of the attest task,
    // the key is the task id, the value is the incentive of the task.
    attestTaskIncentives: map<Int as uint64, Int> = emptyMap();
    // lockedValue is the value that is locked in the contract, cannot be withdrawed.
    lockedValue: Int = ton("0.1");

    init(master: Address, owner: Address){
        self.master = master;
        self.owner = owner;
    }

    // master can set manifest of AttestWallet
    receive(msg: SetWalletManifest){
        require(self.master == sender(), "Only master can set manifest");
        // require(msg.nonce == self.manifestNonce, "Nonce not match");

        emit(WalletManifestChangedEvent{
            oldManifestUrl: self.manifestUrl,
            newManifestUrl: msg.manifestUrl
        }.toCell());

        self.manifestUrl = msg.manifestUrl;
        // self.manifestNonce = self.manifestNonce + 1;
    }

    // owner can withdraw all balance
    receive(msg: WalletWithdraw){
        require(self.owner == sender(), "Only master can withdraw");
        require(myBalance() > self.lockedValue, "Balance not enough");
        send(SendParameters{
                to: sender(),
                value: (myBalance() - context().value) - self.lockedValue,
                bounce: true,
                mode: SendRemainingValue
            }
        );
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();
        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue > ton("0.05"), "Attest value should be greater than 0.05");

        emit(msg.toCell());
        self.lockedValue = self.lockedValue + msg.attestValue;
    }

    // attest task result, and send the incentive to the verifier
    receive(msg: AttestTaskResult) {
        let incentive = self.attestTaskIncentives.get(msg.taskId);
        require(incentive != null, "Task not found");

        msg.verifier = sender();
        emit(msg.toCell());

        // TODO: do not send the incentive to the verifier immediately,
        // add some time lock mechanism, like OP,
        // release the incentive after some period of time to give the submiter a chance to challenge.
        send(SendParameters{
                to: sender(),
                value: incentive!!,
                bounce: true,
                mode: SendRemainingValue
            }
        );
    }

    get fun master(): String {
        return self.master.toString();
    }

    get fun manifestUrl(): String {
        return self.manifestUrl;
    }

    get fun taskIncentives(taskId: Int): Int? {
        return self.attestTaskIncentives.get(taskId);
    }
}
