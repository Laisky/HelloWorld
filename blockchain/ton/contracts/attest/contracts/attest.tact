import "@stdlib/deploy";
import "@stdlib/ownable";

message RegisterBot {
    manifestUrl: String;
    botAddress: Address?;
}

message SetWalletManifest {
    // nonce: Int as uint64;
    manifestUrl: String;
}

message WalletInfo {
    manifestUrl: String;
    owner: Address;
    master: Address;
}

message WalletManifestChangedEvent {
    oldManifestUrl: String;
    newManifestUrl: String;
}

message WalletCreatedEvent {
    wallet: Address;
    owner: Address;
}

message WalletWithdraw {
}

// SubmitAttestTask is the message that generated by the submiter/bot,
// and will be sent to the master contract,
// master contract will forward the message to the wallet contract withing taskId/status/botAddress.
message SubmitAttestTask {
    // task id will be generated by the master contract
    taskId: Int? as uint64;
    // status of the task, can be "pending", "verified" or "rejected", will be set by the master contract
    status: String? = "pending";
    // botAddress is the address of the wallet contract, will be set by the master contract
    botAddress: Address?;
    // proofUrl is the url of the proof, better be stored at arweave
    proofUrl: String;
    // attestValue is the value that will be paid to the attester,
    // the value in the message should be greater than attestValue.
    attestValue: Int;
}

// AttestTaskResult is the result of the attest task, generated by the verifier oracle,
// and will be sent to the wallet contract.
message AttestTaskResult {
    // taskId is the id of the attest task
    taskId: Int as uint64;
    // status is the result of the attest task, can be "verified" or "rejected"
    status: String;
    // verifiedUrl is the url of the verified proof, better be stored at arweave
    verifiedUrl: String;
    // verifier is the address of the verifier oracle,
    // this value will be set by the wallet contract.
    verifier: Address?;
}

message SetStaticTaxFee {
    staticTaxFee: Int;
}

trait Txable with Ownable {
    owner: Address;
    staticTaxFee: Int = ton("0");

    fun getStaticTaxFee(): Int {
        return self.staticTaxFee;
    }

    receive(msg: SetStaticTaxFee){
        self.requireOwner();

        self.staticTaxFee = msg.staticTaxFee;
        let answer = beginString()
            .concat("set static tax fee to ")
            .concat(msg.staticTaxFee.toString())
            .toString();
        self.reply(answer.asComment());
    }
}

// this is the master contract of TON.
contract Attest with Deployable, Ownable, Txable {
    owner: Address;
    attestTaskId: Int as uint64 = 0;
    minimalAttestFee: Int = ton("0.05");
    forwardFee : Int = ton("0.03");
    taxFee: Int = ton("0.01");
    emitFee: Int = ton("0.02");
    staticTaxFee: Int = ton("0.01");

    init(){
        self.owner = sender();
    }

    // create Bot for the sender
    receive(msg: RegisterBot){
        let ctx = context();
        nativeReserve(myBalance() - context().value, ReserveExact);

        require(ctx.value >= self.forwardFee + self.emitFee + self.taxFee, "Value not enough");

        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        msg.botAddress = walletAddr;
        emit(msg.toCell());

        // deploy bot contract and send the manifest to the bot
        send(SendParameters{
                to: walletAddr,
                value: ctx.value - self.emitFee - self.taxFee,
                bounce: false,
                // mode: SendRemainingValue,
                body: SetWalletManifest{
                    manifestUrl: msg.manifestUrl
                }.toCell(),
                code: walletInit.code,
                data: walletInit.data
            }
        );
    }

    fun getWalletInit(walletOwner: Address): StateInit {
        return initOf Bot(myAddress(), walletOwner);
    }

    // update manifest of Bot
    receive(msg: SetWalletManifest){
        let ctx = context();
        nativeReserve(myBalance() - context().value, ReserveExact);

        require(ctx.value >= self.forwardFee + self.taxFee, "Value not enough");

        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        send(SendParameters{
                to: walletAddr,
                value: ctx.value - self.forwardFee - self.taxFee,
                bounce: false,
                // mode: SendRemainingValue,
                body: SetWalletManifest{
                    manifestUrl: msg.manifestUrl
                }.toCell()
            }
        );
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();
        nativeReserve(myBalance() - context().value, ReserveExact);

        require(msg.attestValue >= self.minimalAttestFee, "Attest value should be greater than 0.05");
        require(ctx.value >= msg.attestValue + self.forwardFee + self.taxFee + self.emitFee, "Value not enough");

        let walletInit: StateInit = self.getWalletInit(sender());
        let walletAddr: Address = contractAddress(walletInit);

        msg.taskId = self.attestTaskId;
        msg.status = "pending";
        msg.botAddress = walletAddr;

        // emit attest task to offchain oracle workers
        //
        // Assuming this will use 0.02.
        // In actual, it will cost around 0.007 on the test network.
        emit(msg.toCell());

        // forward the task to Bot
        send(SendParameters{
                to: walletAddr,
                value: ctx.value - self.forwardFee - self.taxFee,
                bounce: false,
                // mode: SendRemainingValue,
                body: msg.toCell()
            }
        );

        self.attestTaskId = self.attestTaskId + 1;
    }
}

// Bot is the wallet contract, will be deployed by the master contract
// to every submiter/bot. wallet contract will take the responsibility of
// storing the manifest and the attest task.
contract Bot with Ownable {
    owner: Address;
    master: Address;
    manifestUrl: String = "";
    // attestTaskIncentives is the balance of the attest task,
    // the key is the task id, the value is the incentive of the task.
    attestTaskIncentives: map<Int as uint64, Int> = emptyMap();
    // lockedValue is the value that is locked in the contract, cannot be withdrawed.
    lockedValue: Int = ton("0.1");

    init(master: Address, owner: Address){
        self.master = master;
        self.owner = owner;
    }

    // master can set manifest of Bot
    receive(msg: SetWalletManifest){
        require(self.master == sender(), "Only master can set manifest");

        emit(WalletManifestChangedEvent{
            oldManifestUrl: self.manifestUrl,
            newManifestUrl: msg.manifestUrl
        }.toCell());

        self.manifestUrl = msg.manifestUrl;
    }

    // owner can withdraw all balance
    receive(msg: WalletWithdraw){
        self.requireOwner();

        nativeReserve(self.lockedValue, ReserveExact);

        send(SendParameters{
                to: sender(),
                value: ton("0"),
                bounce: false,
                mode: SendRemainingBalance
            }
        );
    }

    // submit attest task
    receive(msg: SubmitAttestTask){
        let ctx = context();

        require(self.master == sender(), "Only master can submit attest task");
        require(self.manifestUrl != "", "Manifest not set");
        require(ctx.value >= msg.attestValue, "Attest value not enough");
        require(msg.attestValue >= ton("0.05"), "Attest value should be greater than 0.05");
        require(msg.botAddress == myAddress(), "Wallet address not match");
        require(msg.taskId != null, "Task id not set");

        // lock the incentive of the task for the attester
        self.lockedValue = self.lockedValue + msg.attestValue;

        // save the incentive of the task
        self.attestTaskIncentives.set(msg.taskId!!, msg.attestValue);
    }

    // attest task result, and send the incentive to the verifier
    receive(msg: AttestTaskResult) {
        let incentive = self.attestTaskIncentives.get(msg.taskId);
        require(incentive != null, "Task not found");

        msg.verifier = sender();
        emit(msg.toCell());

        // TODO: need to check the correctness of the result.
        //
        // do not send the incentive to the verifier immediately,
        // add some time lock mechanism, like OP,
        // release the incentive after some period of time to give the submiter a chance to challenge.
        send(SendParameters{
                to: sender(),
                value: incentive!!,
                bounce: false,
                mode: SendRemainingValue
            }
        );
        self.attestTaskIncentives.set(msg.taskId, null);
    }

    get fun master(): String {
        return self.master.toString();
    }

    get fun manifestUrl(): String {
        return self.manifestUrl;
    }

    get fun taskIncentives(taskId: Int): Int {
        let val = self.attestTaskIncentives.get(taskId);
        if (val == null) {
            return 0;
        }

        return val!!;
    }

    get fun lockedValue(): Int {
        return self.lockedValue;
    }
}
